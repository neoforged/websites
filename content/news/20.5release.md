---
title: "NeoForge 20.5 for Minecraft 1.20.5"
date: 2024-04-11T08:25:00+02:00
categories:
- News
author: neoforgedteam
summary: |
    All you need to know about NeoForge 20.5, now released for Minecraft 1.20.5.
description: |
    All you need to know about NeoForge 20.5, now released for Minecraft 1.20.5.
---

_This post is still a draft._ <!-- TODO remove this line -->

The first beta release of NeoForge for Minecraft 1.20.5, NeoForge 20.5.TODO-beta is now released!
Please try it out, play with it, develop with it, and give us feedback!
**We are not stable yet**, so expect a few breaking changes in the coming weeks.
If you are a contributor, now is a great time to start working on your Pull Requests.

For players, you can grab the latest installer directly from https://neoforged.net/.

There are a few important breaking changes in NeoForge,
but must of the technical changes come from Minecraft 1.20.5 itself.

****

## `neoforge.mods.toml`
Starting from 20.5, the only recognized metadata file for mods is `neoforge.mods.toml`,
still in the `META-INF` folder.
All `mods.toml` files must be renamed to `neoforge.mods.toml` to be recognized by NeoForge.
This change was made to make identifying NeoForge mods easier,
considering that `mods.toml` is also in use by MinecraftForge.

Remember to replace `mods.toml` by `neoforge.mods.toml` **in your Gradle scripts** too,
especially in the `processResources` block.

## Item Data Components
`ItemStack`s do not have a `CompoundTag` anymore.
Instead, a stack can now have any number of data components.
Each data component is a plain Java object, identified by a `DataComponentType`.

Modders should generally create and register their own `DataComponentType`s to store data on item stacks.
The vanilla component types are available in the `DataComponentTypes` class.

{{< box warning >}}
Stack copies are shallow, which means that the components themselves are shared between stacks.
Components are compared using `equals` for stack comparisons,
and `hashCode` can also be called when hashing stacks.
**Therefore, data components must be immutable, and provide a correct implementation of `equals` and `hashCode`.**
NeoForge adds a sanity check to make sure that components override these methods.
{{< /box >}}

For example, assuming that we want to store a single integer on an ItemStack, the code would have to change as follows:
```diff
+ DataComponentType<Integer> ENERGY = ...;

- int energy = stack.getOrCreateTag().getInt("energy");
+ int energy = stack.getOrDefault(ENERGY, 0);

- stack.getOrCreateTag().setInt("energy", 10);
+ stack.set(ENERGY, 10);
```

For reference, have a look at the following code:
- All of `DataComponentType` and `DataComponentType.Builder`.
- `DataComponentHolder` which is implemented by item stacks.
- `ItemStack.set(..., ...)` and `ItemStack.remove(...)` to change the components on a stack.
- `ItemStack.update(...)` for convenience when updating the value of a component.

`Item`s can provide a default set of components.
- See `Item.Properties.component(...)` to add default components to items.

### Comparison with Data Attachments
Stack data attachments were removed since they are superseded by this new system.
While attachments were mutable and unique to each stack,
data components are shared between stacks and **must therefore be immutable**.

For now, data attachments are still fully functional on other types of objects (block entities, chunks, entities, and levels).

## Networking Updates
TODO

## DFU Update
The DFU (DataFixerUpper) library was updated from major version 6 to 7.
This update fixes many longstanding a(nnoyances with DFU,
at the cost of a few breaking changes.

Here are a few highlights:
- Many methods in `ExtraCodecs` (a Minecraft class that contains additional `Codec`s) were removed,
as they now have an equivalent in DFU itself.
    - `ExtraCodecs.strictOptionalField(codec, ...)` is replaced by `codec.optionalFieldOf(...)`, which is now strict by default.
    - `ExtraCodecs.validate(codec, ...)` is replaced by `codec.validate(...)`.
    - `ExtraCodecs.lazyInitializedCodec(() -> ...)` is replaced by `Codec.lazilyInitialized(() -> ...)`.
    - And so on...
- Dispatch codecs (typically, codecs whose serialization depends on a `type` field) now require a `MapCodec` for the dispatched type. For example, recipe serializers now return a `MapCodec` instead of a `Codec`.
    - When using `RecordCodecBuilder`, use `RecordCodecBuilder.mapCodec` instead of `.create` to produce a `MapCodec`.
    - Many combinators such as `.xmap` will work with `MapCodec`s too.
    - Turning a `MapCodec` to a `Codec` is done using `mapCodec.codec()`.
- `Util.getOrThrow(dataResult, ...)` is replaced by `dataResult.getOrThrow(...)`.


## Smaller Changes
TODO

## Porting Primer
A lot of smaller changes are collected on the following [Mod Migration Primer](https://gist.github.com/ChampionAsh5357/53b04132e292aa12638d339abfabf955). Thanks to `@ChampionAsh5357` for this write-up.

## 1.20.4 Plans
TODO - what are the plans

